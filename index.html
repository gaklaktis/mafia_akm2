<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>–ú–∞—Ñ–∏—è ‚Äî –¢–∞–±–ª–∏—Ü–∞</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 10px; background: white; }
    table { border-collapse: collapse; width: 100%; }
    td, th { border: 1px solid #ccc; padding: 5px; text-align: center; min-width: 40px; }
    .cell { cursor: pointer; }
    .red { background: #f88 !important; }
    .green { background: #8f8 !important; }
    .purple { background: #d8b6ff !important; }
    .pink { background: #ffc0cb !important; }
    .gradient-pink-purple { background: linear-gradient(45deg, #ffc0cb 50%, #d8b6ff 50%); }
    .gradient-pink-green { background: linear-gradient(45deg, #ffc0cb 50%, #8f8 50%); }
    .gradient-pink-red { background: linear-gradient(45deg, #ffc0cb 50%, #f88 50%); }
    .num-red { background: #f55 !important; color: white; font-weight: bold; }
    #selectedPlayer {
      font-size: 440px;
      text-align: center;
      margin-top: 500px;
      font-weight: bold;
      color: red;
      padding-bottom: 500px;
    }
    #loadFile { display: none; }
    label[for="loadFile"] {
      background-color: #eee;
      border: 1px solid #ccc;
      padding: 6px 12px;
      cursor: pointer;
      user-select: none;
      margin-left: 10px;
      border-radius: 4px;
      font-size: 14px;
    }
    label[for="loadFile"]:hover { background-color: #ddd; }
  </style>
</head>
<body>

<h3>–¢–∞–±–ª–∏—Ü–∞ –Ω–æ—á–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π</h3>
<div style="background: #f0f0f0; padding: 10px; margin-bottom: 10px;">
  <b>–ü–æ–¥—Å–∫–∞–∑–∫–∞ –ø–æ —Ä–æ–ª—è–º:</b><br>
  –ü ‚Äî –ø—É—Ç–∞–Ω–∞, –õ ‚Äî –ª—é–±–æ–≤–Ω–∏—Ü–∞, –• ‚Äî –º–∞—Ñ–∏—è, –•–¥ ‚Äî –¥–æ–Ω, –í ‚Äî –¥–æ–∫—Ç–æ—Ä, –® ‚Äî —à–µ—Ä–∏—Ñ, –ú ‚Äî –º–∞–Ω—å—è–∫, –ö ‚Äî –∫–∞–º–∏–∫–∞–¥–∑–µ, –° ‚Äî –º—Å—Ç–∏—Ç–µ–ª—å
</div>

<div>
  <button onclick="exportData()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
  <label for="loadFile">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å</label>
  <input type="file" id="loadFile" accept=".json" />
  <button onclick="resetTable()">‚ôªÔ∏è –°–±—Ä–æ—Å</button>
  <button onclick="exportToExcel()">üì§ –í Excel</button>
</div>

<table id="mafiaTable">
  <thead>
    <tr id="headerRow"><th>#</th><th>–†–æ–ª—å</th></tr>
  </thead>
  <tbody id="tableBody"></tbody>
</table>

<div id="selectedPlayer"></div>

<script>
  const playerCount = parseInt(new URLSearchParams(location.search).get("count")) || 10;
  const nightCount = 9;
  const headerRow = document.getElementById("headerRow");
  const tableBody = document.getElementById("tableBody");

  for (let n = 1; n <= nightCount; n++) {
    const th = document.createElement("th");
    th.textContent = `–ù–æ—á—å ${n}`;
    headerRow.appendChild(th);
  }

  const roleOptions = ["", "–ü", "–õ", "–•", "–•–¥", "–í", "–®", "–ú", "–ö", "–°"];

  function resetColorClasses(cell) {
    cell.classList.remove("red", "green", "purple", "pink",
      "gradient-pink-purple", "gradient-pink-green", "gradient-pink-red");
  }

  function getCellClass(text) {
    const parts = text.toUpperCase().split("\\").map(p => p.trim());
    const has = r => parts.includes(r);

    const hasP = has("–ü");
    const hasL = has("–õ");
    const hasV = has("–í");
    const hasX = has("–•");
    const hasM = has("–ú");
    const hasXXX = has("–•–•–•");

    if (hasXXX) return "red";
    if (hasP && hasL) return "gradient-pink-purple";
    if (hasP && hasV) return "gradient-pink-green";
    if (hasP && (hasX || hasM)) return "gradient-pink-red";
    if (hasL) return "purple";
    if (hasV) return "green";
    if (hasX || hasM) return "red";
    if (hasP) return "pink";
    return "";
  }

  function updateRowColors(row) {
    const cells = [...row.querySelectorAll(".cell")];
    const numCell = row.querySelector("td");
    numCell.classList.remove("num-red");
    cells.forEach(c => c.classList.remove("red"));

    for (let i = 0; i < cells.length; i++) {
      const val = cells[i].textContent.toUpperCase();
      const parts = val.split("\\").map(p => p.trim());
      const hasKill = parts.includes("–•") || parts.includes("–ú");
      const hasCancel = parts.includes("–õ") || parts.includes("–í");
      const hasXXX = parts.includes("–•–•–•");

      if (hasXXX) {
        numCell.classList.add("num-red");
        resetColorClasses(cells[i]);
        cells[i].classList.add("red");
        return;
      }

      if (hasKill && !hasCancel) {
        numCell.classList.add("num-red");
        const style = getCellClass(val);
        resetColorClasses(cells[i]);
        if (style.startsWith("gradient-pink-")) {
          cells[i].classList.add(style);
        } else {
          cells[i].classList.add("red");
        }
        return;
      }
    }
  }

  function createTable(count) {
    tableBody.innerHTML = "";
    for (let i = 1; i <= count; i++) {
      const row = document.createElement("tr");

      const numCell = document.createElement("td");
      numCell.className = "number-cell";
      numCell.textContent = i;
      numCell.onclick = () => {
        document.getElementById("selectedPlayer").textContent = i;
      };
      row.appendChild(numCell);

      const roleCell = document.createElement("td");
      const select = document.createElement("select");
      roleOptions.forEach(opt => {
        const o = document.createElement("option");
        o.value = opt;
        o.textContent = opt;
        select.appendChild(o);
      });
      roleCell.appendChild(select);
      row.appendChild(roleCell);

      for (let n = 1; n <= nightCount; n++) {
        const cell = document.createElement("td");
        cell.className = "cell";
        row.appendChild(cell);
      }

      tableBody.appendChild(row);
    }
  }

  createTable(playerCount);

  document.addEventListener("click", e => {
    if (e.target.classList.contains("cell")) {
      const cell = e.target;
      const row = cell.parentElement;
      let input = prompt("–•, –ú, –í, –õ, –ü, –®, –ö, –°, –•–•–•. –£–¥–∞–ª–∏—Ç—å ‚Äî 0. –£–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ ‚Äî 00");
      if (input === null) return;
      input = input.toUpperCase().trim();

      if (input === "0") {
        cell.textContent = "";
      } else if (input === "00") {
        const parts = cell.textContent.split("\\");
        parts.pop();
        cell.textContent = parts.join("\\");
      } else if (/^(–•|–ú|–í|–õ|–ü|–®|–ö|–°|–•–•–•)$/.test(input)) {
        cell.textContent = cell.textContent ? cell.textContent + "\\" + input : input;
      }

      resetColorClasses(cell);
      cell.className = "cell";
      const style = getCellClass(cell.textContent);
      if (style) cell.classList.add(style);

      updateRowColors(row);
    }
  });

  async function exportData() {
    const data = { count: playerCount, rows: [] };
    tableBody.querySelectorAll("tr").forEach(row => {
      const tds = row.querySelectorAll("td");
      const role = tds[1].querySelector("select").value;
      const nights = [...tds].slice(2).map(c => c.textContent);
      data.rows.push({ role, nights });
    });

    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });

    if (window.showSaveFilePicker) {
      try {
        const now = new Date();
        const date = now.toISOString().split("T")[0];
        const time = `${now.getHours()}-${now.getMinutes()}`;
        const fileHandle = await window.showSaveFilePicker({
          suggestedName: `mafia_${date}_${time}.json`,
          types: [{ description: 'JSON File', accept: { 'application/json': ['.json'] } }]
        });
        const writable = await fileHandle.createWritable();
        await writable.write(blob);
        await writable.close();
        alert("–§–∞–π–ª —Å–æ—Ö—Ä–∞–Ω—ë–Ω —É—Å–ø–µ—à–Ω–æ ‚úÖ");
        return;
      } catch (err) {
        if (err.name !== "AbortError") {
          alert("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å: " + err.message);
        }
      }
    }

    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = `mafia_data.json`;
    link.click();
  }

  function importData(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = evt => {
      const data = JSON.parse(evt.target.result);
      createTable(data.count);
      data.rows.forEach((r, i) => {
        const row = tableBody.children[i];
        row.querySelector("select").value = r.role;
        const cells = [...row.querySelectorAll(".cell")];
        r.nights.forEach((val, j) => {
          const c = cells[j];
          c.textContent = val;
          resetColorClasses(c);
          c.className = "cell";
          const style = getCellClass(val);
          if (style) c.classList.add(style);
        });
        updateRowColors(row);
      });
    };
    reader.readAsText(file);
    e.target.value = "";
  }

  function resetTable() {
    if (confirm("–û—á–∏—Å—Ç–∏—Ç—å –≤—Å—é —Ç–∞–±–ª–∏—Ü—É?")) {
      localStorage.removeItem("mafia_table");
      createTable(playerCount);
    }
  }

  function exportToExcel() {
    const wb = XLSX.utils.book_new();
    const data = [];

    const header = ["#", "–†–æ–ª—å"];
    for (let i = 1; i <= nightCount; i++) {
      header.push(`–ù–æ—á—å ${i}`);
    }
    data.push(header);

    tableBody.querySelectorAll("tr").forEach((row, idx) => {
      const tds = row.querySelectorAll("td");
      const playerNum = idx + 1;
      const role = tds[1].querySelector("select").value;
      const nights = [...tds].slice(2).map(c => c.textContent);
      data.push([playerNum, role, ...nights]);
    });

    const ws = XLSX.utils.aoa_to_sheet(data);
    XLSX.utils.book_append_sheet(wb, ws, "–¢–∞–±–ª–∏—Ü–∞");

    const now = new Date();
    const date = now.toISOString().split("T")[0];
    const time = `${now.getHours()}-${now.getMinutes()}`;
    XLSX.writeFile(wb, `mafia_${date}_${time}.xlsx`);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const saved = localStorage.getItem("mafia_table");
    if (saved) {
      const data = JSON.parse(saved);
      createTable(data.count);
      data.rows.forEach((r, i) => {
        const row = tableBody.children[i];
        row.querySelector("select").value = r.role;
        const cells = [...row.querySelectorAll(".cell")];
        r.nights.forEach((val, j) => {
          const c = cells[j];
          c.textContent = val;
          resetColorClasses(c);
          c.className = "cell";
          const style = getCellClass(val);
          if (style) c.classList.add(style);
        });
        updateRowColors(row);
      });
    }
  });

  document.getElementById("loadFile").addEventListener("change", importData);
</script>

</body>
</html>
